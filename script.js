// Особенности современного стандарта ES6
'use strict'

/* const foo = (name, age) => {} - стрелочная функция
	Она имеет несколько приятных ньюансов
	1. короткий формат записи
	2. Полное отсутсвие контекста вызова(this) - главное преимущество
	this - контекст вызова.
	Если все методы/функции в нутри объекта будут написаны стрелочной нотацией, тогда проблем с 
	контекстом вызова не будет, контекст вызова будет ссылатся на сам объект
*/

// Пример

const user = {
	name: 'Alex',
	age: 34, 
	say() { // вид записи стрелочной функции(стерлочный метод) в объекте
		// console.log(this); // this все равно видит значения объекта user
		const foo = function (name, age) { // () => стрелочная функция меняет этот момент(метод становится частью объекта)
			// стрелочная функция собственого контекста вызова не имеет, поэтому она берет контекст уровня выше
			// console.log(this); // undefined - пытается обратится к глобальному объекту window
			// console.log("Привет, меня зовут " + name + "!");
			// console.log("Мне " + age + "года");
		}
		foo(this.name, this.age); // вызов самой функции не относится не к одному объекту, объекту не пренадлежит
	}
}

user.say();

// Интрополяция или шаблонные строки
// `` - backtick-и  (обратные ковычки)
// ------------------------------------------------------------
// Classes

// функция-конструктор, всегда начинается с заглавной буквы
const Person1 = function(name, age) {
	this.name = name
	this.age = age
// метод писать луше в не конструктора, так как влияет на произваодительность
	Person1.prototype.sayHello = function() {
	// console.log(`Привет! меня зовут ${this.name}`);
	}
}
// лучше писать метод за пределами функции-конструктора
Person1.prototype.sayHello = function() {
	// console.log(`Привет! меня зовут ${this.name}`);
}

// создан новый объект
const person1 = new Person1('Vlad', 23)
person1.sayHello()
// console.log(person1);
// --------------------------------------------------------------------------------------------------------------------

// у классов есть такой же конструктор как и у функции-конструктор
// class Person выступает конструтором нашего объекта, под капотом она работает так же как функция-конструктор
class Person {
	// но для это используется специальный метод - конструктор, он и принемает наши аргументы
	constructor(name, age) {
		// в нутри данного метода, определяются свойства будущего объекта
		this.name = name;
		this.age = age;
		// вызов статического метода
		Person.incrementCount();
	}
	/* переменная count созданная внутри класса статическая, то есть она доступна общему классу,
	но экземпляру класса она не доступна.
	Сами по себе статически переменные и методы, записываются на прямую в конструктор, они не пренадлежат создаваемым
	объектам на основе данного класса, поэтому не увеличивают вес данного объекта.
	Обычно статические свойства и методы, реализуют функционал пренадлежащий самому классу Person, и не как не относящийся
	к его экземпляру
	*/
	static count = 0;
	// статический метод
	static getCount() {
		// console.log(this);
		return this.count 
	}

	static incrementCount() {
		Person.count++
	}
	// благодоря классов метод реализуется в разы проще
	// метод в class может использовать локальные переменный и при этом являтся глобальным методом - он есть в прототипе
	// метод тоже не увеличивает вес данного(person) объекта, так как он не находится в самом конструкторе
	sayHello() {
		console.log(`Привет! меня зовут ${this.name}`);
	}
}

// новый созданный объект (экзэмпляр класса)
const person = new Person('Vlad', 23);
// проверка веса объекта person
// console.log(JSON.stringify(person));
console.log(person);
person.sayHello();
// для экзэмпляра person переменная count не доступна
// console.log(person.count);
// только с самого класса
// console.log(Person.getCount());

// Наследование классов
// класс FrontAndDev
// и унаследуем его от класса Person то.есть FrontAndDev наследуется <- от Person
// extends - ператор, чтобы унаследоваться(то есть-брать свойства и методы от класса Person) от класса Person
class FrontEndDev extends Person {
	constructor(name, age, skills = []) {
		// метод super это связывающее звено между калссом наследником(FrontEndDev) и классом прототипа(Person)
		// через данный метод, можем обращаться к методам родительского класса
		super(name, age)
		this._skills = skills
	}

	test() {
		super.sayHello()
	}
// гетер - это метод, который по названию полностью схож по названию с тем свойством с которым он будет работать
// по чути это и есть свойство, по сути это даже не метод???
	get skills() {
		// данный метода всегда что то возвращает
		/* гетэр работает только со свойствами у которых в имени есть _skills - данной свойство созданно только для чтения,
			оно не созданно для записи, это флажек(_) указывает, что на прямую это свойство менять нельзя
		*/
		// это живое свойство, живое потому что гетер всегда будет возвращать свойство с _skills
		return this._skills
	}
	// сетэр
	set skills(str) {
		this.skills.push(str)
	}

}
// объект-экзэмпляр класса FrontAndDev
const dev = new FrontEndDev('Vlad', 23);
dev.skills = "первое свойство"
console.log(dev);
dev.sayHello();
// статические переменные и методы также унаследуються от класса Person
console.log(FrontEndDev.count);


// ДЗ
console.log('');
console.log('дз');


class First {
	hello() {
		console.log("Привет я метод родителя!");
	}
}
// класс Second наследует от класса First
class Second extends First {
	hello() {
		super.hello();
		console.log("А я наследуемый метод!");
	}
}
// объект-экзэмпляр класса Second
const fourth = new Second();
fourth.hello();